##### ДЗ Тема 9. Асинхронне програмування, Тема 10. Вступ до паралельних обчислень


##### ДЗ Тема 9. Асинхронне програмування

### Завдання 1
'''
Напишіть Python-скрипт, який буде читати всі файли у вказаній користувачем вихідній папці (source folder) і розподіляти їх по підпапках у директорії призначення (output folder) на основі розширення файлів. Скрипт повинен виконувати сортування асинхронно для більш ефективної обробки великої кількості файлів.

Покрокова інструкція

1. Імпортуйте необхідні асинхронні бібліотеки.
2. Створіть об'єкт ArgumentParser для обробки аргументів командного рядка.
3. Додайте необхідні аргументи для визначення вихідної та цільової папок.
4. Ініціалізуйте асинхронні шляхи для вихідної та цільової папок.
5. Напишіть асинхронну функцію read_folder, яка рекурсивно читає всі файли у вихідній папці та її підпапках.
6. Напишіть асинхронну функцію copy_file, яка копіює кожен файл у відповідну підпапку у цільовій папці на основі його розширення.
7. Налаштуйте логування помилок.
8. Запустіть асинхронну функцію read_folder у головному блоці.

Критерії прийняття

- Код виконує асинхронне читання та копіювання файлів.
- Файли розподілено по підпапках на основі їх розширень.
- Програма обробляє аргументи командного рядка.
- Усі помилки логовано.
- Код читабельний та відповідає стандартам PEP 8.
'''

import argparse
import asyncio
import logging
import sys # argparse, asyncio, logging, sys: Стандартні бібліотеки для обробки аргументів командного рядка, асинхронного програмування, ведення логів і системних функцій.

from aiopath import AsyncPath
from aioshutil import copyfile # AsyncPath з aiopath та copyfile з aioshutil: Це асинхронні аналоги стандартних функцій pathlib.Path та shutil.copyfile, які дозволяють виконувати операції з файловою системою асинхронно, не блокуючи головний потік.

from pathlib import Path # Path з pathlib: Використовується в argparse для коректного опрацювання шляхів.


### 3) Рекурсивно читаємо всі файли у вихідній папці та її підпапках

async def read_folder(source: AsyncPath) -> None:  # Асинхронна функція приймає асинхронний шлях до директорії.
# Дописати асинхронну функцію, яка рекурсивно читає всі файли у вихідній папці та її підпапках
# Схожий код як було в курсі "Базові Алгоритми", але тепер з async та await (файл goit-algo-hw-03.py, курс 3) Basic Algorithms and Data Structures)
    try:
        async for element in source.iterdir(): # Це асинхронний цикл, який ітерує по вмісту директорії. source.iterdir() — це асинхронний ітератор, який повертає об'єкти AsyncPath для кожного елемента.
            if await element.is_dir():    # Перевіряє, чи є елемент директорією. await потрібен, бо is_dir() є асинхронною операцією.
                await read_folder(element)  # Якщо це директорія, функція викликає себе рекурсивно, занурюючись глибше.
            elif await element.is_file(): # Якщо елемент — файл, його передають для копіювання.
                await copy_file(element)    # Асинхронно викликаємо функцію копіювання для поточного файлу.
    except (PermissionError, FileNotFoundError) as e: # Обробляє можливі помилки доступу або відсутності директорії, записуючи їх у лог, щоб програма не аварійно завершувалася, а продовжувала роботу з іншими файлами.
        logging.error(f"Cannot access directory {source}: {e}") # Якщо не можемо отримати доступ до директорії, повертаємося, щоб не зупиняти програму


#### 4) Копіюємо кожен файл у конкертну підпадку відповідно до розширення файлу

async def copy_file(file: AsyncPath) -> None:      # Асинхронна функція приймає асинхронний шлях до файлу.
    #TODO Логування обробки помилок через logging
    try:                                             # Використовується блок для обробки будь-яких помилок під час копіювання файлу, наприклад, якщо не вдалося створити директорію або скопіювати файл.
        extension_name = file.suffix[1:] if file.suffix else "no_extension" # Цей рядок отримує розширення файлу. file.suffix повертає рядок на кшталт '.txt', тому [1:] прибирає крапку. Якщо розширення відсутнє, створюється папка no_extension.
        extension_folder = output / extension_name                          # Створює асинхронний шлях до цільової підпапки для файлів з конкретним розширенням.
        
        await extension_folder.mkdir(exist_ok=True, parents=True) # Асинхронно створює цільову підпапку. exist_ok=True запобігає помилці, якщо папка вже існує, а parents=True створює батьківські папки за потреби.
        await copyfile(file, extension_folder / file.name)        # Асинхронно копіює файл з його поточного розташування в щойно створену підпапку.
        logging.info(f"Copied file '{file.name}' to '{extension_folder}'") # Записує повідомлення про успішне копіювання файлу, що допомагає відстежувати прогрес.
    except Exception as e:
        logging.error(f"Failed to copy file '{file.name}': {e}")



#### 0) Налаштовуємо логування виведення інформації в консоль та парсинг аргументів з консолі

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(threadName)s %(message)s") # Налаштовує систему логування, щоб виводити інформацію в консоль.

    parser = argparse.ArgumentParser(
        description="Recursively copy and sort files from source to output by extension."
    ) # Створює парсер аргументів, який допомагає програмі приймати вхідні дані з командного рядка.
    
    parser.add_argument(
        "source",
        type=Path,
        help='Path to the source directory'
    ) #  Додає аргументи source (обов'язковий) і output (необов'язковий, зі значенням за замовчуванням dist).
    parser.add_argument(
        "output",
        nargs="?",
        default=Path("dist"),
        type=Path,
        help="Path to the output directory (default: ./dist)"
    )

    args = parser.parse_args() #  Парсить аргументи, передані користувачем.

    source = AsyncPath(args.source) # Перетворює отримані рядкові шляхи на об'єкти AsyncPath для асинхронної роботи.
    output = AsyncPath(args.output)


### 1) Перевірка наявності та типу вихідної директорії

    async def main():
        if not await source.exists() or not await source.is_dir():     # Це перша асинхронна операція. Вона перевіряє, чи існує об'єкт за шляхом, який зберігається в змінній source. Використання await дозволяє програмі не блокуватися, очікуючи відповіді від файлової системи. if not ... or not ...: Цей умовний вираз комбінує результати обох перевірок. Код у блоці if виконається, якщо: директорія не існує (not await source.exists() є True). або якщо об'єкт існує, але не є директорією (not await source.is_dir() є True).
            logging.error(f"Source directory '{source}' does not exist or is not a directory.") # Друга асинхронна операція, що перевіряє, чи є об'єкт за шляхом source саме директорією. logging.error(...): Якщо умова істинна, записується повідомлення про помилку, що є кращим підходом, ніж просто print(), оскільки це дозволяє налаштувати виведення логів.
            sys.exit(1)                                                                         # Ця команда негайно зупиняє виконання всієї програми з кодом виходу 1. Код 1 зазвичай означає, що програма завершилася з помилкою. Це гарантує, що програма не буде продовжувати роботу з некоректними даними, що може призвести до непередбачуваних результатів.

### 2) Запуск основного процесу сортування (копіювання)        
        logging.info(f"Starting file sorting from '{source}' to '{output}'...") # Якщо попередні перевірки пройшли успішно, цей рядок виводить інформаційне повідомлення, що вказує на початок роботи. Це корисно для моніторингу роботи програми.
        await read_folder(source)                                               # Це основна команда, яка запускає весь процес сортування (копіювання). Вона асинхронно викликає функцію read_folder, передаючи їй шлях до вихідної директорії. Ключове слово await тут є критично важливим, оскільки воно змушує функцію main чекати, доки read_folder (разом з усіма її рекурсивними викликами та копіюванням файлів) повністю не завершить свою роботу.
        logging.info("File sorting completed.")                                 # Після того, як read_folder завершиться, цей рядок виводить фінальне повідомлення про успішне завершення, сигналізуючи, що програма виконала своє завдання.

    asyncio.run(main()) # Запускає асинхронну функцію main. Вона перевіряє існування вихідної папки та запускає процес сортування, а потім виводить повідомлення про завершення.

    # Для перевірки на умову виконання PEP8 рекомендую використати pycodestyle
    # pip install pycodestyle
    # Приклад застосування "pycodestyle --show-source --show-pep8 exercise_10_async.py"

'''
Схема виконання коду

1.  **Початок `main`**: Функція починає виконання.

2.  **Перевірка вхідного шляху**:
    * Виконується `await source.exists()`. `main` призупиняється.
    * Якщо шлях існує, виконується `await source.is_dir()`. `main` знову призупиняється.

3.  **Обробка помилки**:
    * Якщо будь-яка з перевірок повертає `False`, програма виводить помилку в лог і негайно завершує роботу.

4.  **Запуск сортування**:
    * Якщо шлях коректний, програма виводить повідомлення "Starting...".
    * Викликається `await read_folder(source)`.
    * `main` **призупиняється і чекає**, доки `read_folder` не виконає всю свою роботу (рекурсивне читання та копіювання).

5.  **Завершення**:
    * Коли `read_folder` повертає управління, `main` відновлює виконання.
    * Виводиться повідомлення "File sorting completed.".
    * Виконання функції `main` завершується, а разом з нею — і програма.
'''

##### Примітка:
# в термінал необхідно ввести наступні команди, аби виконався код вище
# cd "C:\Users\User\Desktop\GOIT\My_repo\Basic-Algorithms-and-Data-Structures\Chapter10"
# py goit-cs-hw-051.py ./pictures ./pictures_copy
# натиснути Enter
# Для перевірки на умову виконання PEP8 рекомендую використати pycodestyle
# ввести в консоль pycodestyle --show-source --show-pep8 goit-cs-hw-051.py


#### Питання: щр робить цей код?
  # logging.basicConfig(level=logging.INFO, format="%(threadName)s %(message)s")
'''
Цей рядок коду налаштовує систему логування в Python. Він задає базові параметри, які визначають, як повідомлення будуть оброблятися та відображатися. Давайте розберемо кожен аргумент покроково.

### Покроковий розбір

1.  **`logging.basicConfig(...)`**
    * Це функція з вбудованого модуля `logging`, яка використовується для швидкого та простого налаштування кореневого логгера (root logger). Вона зручна для невеликих програм або для початкового налаштування.

2.  **`level=logging.INFO`**
    * **`level`** — це аргумент, який встановлює мінімальний рівень важливості для повідомлень, які будуть оброблятися. Усього існує кілька рівнів:
        * `logging.DEBUG` (найнижчий)
        * **`logging.INFO`**
        * `logging.WARNING`
        * `logging.ERROR`
        * `logging.CRITICAL` (найвищий)
    * `level=logging.INFO` означає, що програма буде обробляти та виводити в консоль усі повідомлення з рівнем **`INFO`** та вище (`WARNING`, `ERROR`, `CRITICAL`). Повідомлення рівня `DEBUG` будуть ігноруватися.

3.  **`format="%(threadName)s %(message)s"`**
    * **`format`** — це аргумент, який визначає формат вихідного повідомлення. Він використовує рядки форматування, щоб включити в повідомлення різні дані, як-от ім'я потоку, час, рівень важливості тощо.
    * **`%(threadName)s`**: Цей шаблон вставляє **ім'я потоку**, у якому було згенеровано повідомлення. Це дуже корисно в багатопотокових програмах (наприклад, з `ThreadPoolExecutor`), оскільки допомагає відстежувати, який потік виконав певну дію.
    * **`%(message)s`**: Цей шаблон вставляє **текст самого повідомлення**, який був переданий до функції логування (наприклад, `logging.info("Файл скопійовано")`).

### Схема роботи

Отже, коли ви запускаєте програму, `logging.basicConfig(...)` один раз налаштовує систему логування. Після цього, коли в коді з'являється рядок на кшталт `logging.info("Starting file sorting...")`, система:

1.  Перевіряє, чи рівень повідомлення (`INFO`) відповідає або перевищує мінімальний рівень, встановлений у `basicConfig` (у нашому випадку це `INFO`). Оскільки `INFO >= INFO`, повідомлення буде оброблено.
2.  Форматує повідомлення відповідно до заданого шаблону.
3.  Виводить його в консоль.

**Приклад виведення:**
Якщо ваше повідомлення було `logging.info("Starting file sorting...")`, а воно було згенеровано в потоці з ім'ям `MainThread`, виведення буде таким:

`MainThread Starting file sorting...`

Якщо інше повідомлення було згенеровано у фоновому потоці з ім'ям `ThreadPoolExecutor-0_1`, виведення буде:

`ThreadPoolExecutor-0_1 Copied file 'example.txt'`

Це дозволяє легко відрізняти, які дії відбуваються в головному потоці, а які — в допоміжних.
'''