##### ДЗ Тема 9. Асинхронне програмування, Тема 10. Вступ до паралельних обчислень


##### ДЗ Тема 9. Асинхронне програмування

### Завдання 1
'''
Напишіть Python-скрипт, який буде читати всі файли у вказаній користувачем вихідній папці (source folder) і розподіляти їх по підпапках у директорії призначення (output folder) на основі розширення файлів. Скрипт повинен виконувати сортування асинхронно для більш ефективної обробки великої кількості файлів.

Покрокова інструкція

1. Імпортуйте необхідні асинхронні бібліотеки.
2. Створіть об'єкт ArgumentParser для обробки аргументів командного рядка.
3. Додайте необхідні аргументи для визначення вихідної та цільової папок.
4. Ініціалізуйте асинхронні шляхи для вихідної та цільової папок.
5. Напишіть асинхронну функцію read_folder, яка рекурсивно читає всі файли у вихідній папці та її підпапках.
6. Напишіть асинхронну функцію copy_file, яка копіює кожен файл у відповідну підпапку у цільовій папці на основі його розширення.
7. Налаштуйте логування помилок.
8. Запустіть асинхронну функцію read_folder у головному блоці.

Критерії прийняття

- Код виконує асинхронне читання та копіювання файлів.
- Файли розподілено по підпапках на основі їх розширень.
- Програма обробляє аргументи командного рядка.
- Усі помилки логовано.
- Код читабельний та відповідає стандартам PEP 8.
'''

import argparse
import asyncio
import logging
import sys # argparse, asyncio, logging, sys: Стандартні бібліотеки для обробки аргументів командного рядка, асинхронного програмування, ведення логів і системних функцій.

from aiopath import AsyncPath
from aioshutil import copyfile # AsyncPath з aiopath та copyfile з aioshutil: Це асинхронні аналоги стандартних функцій pathlib.Path та shutil.copyfile, які дозволяють виконувати операції з файловою системою асинхронно, не блокуючи головний потік.

from pathlib import Path # Path з pathlib: Використовується в argparse для коректного опрацювання шляхів.


### 3) Рекурсивно читаємо всі файли у вихідній папці та її підпапках

async def read_folder(source: AsyncPath) -> None:  # Асинхронна функція приймає асинхронний шлях до директорії.
# Дописати асинхронну функцію, яка рекурсивно читає всі файли у вихідній папці та її підпапках
# Схожий код як було в курсі "Базові Алгоритми", але тепер з async та await (файл goit-algo-hw-03.py, курс 3) Basic Algorithms and Data Structures)
    try:
        async for element in source.iterdir(): # Це асинхронний цикл, який ітерує по вмісту директорії. source.iterdir() — це асинхронний ітератор, який повертає об'єкти AsyncPath для кожного елемента.
            if await element.is_dir():    # Перевіряє, чи є елемент директорією. await потрібен, бо is_dir() є асинхронною операцією.
                await read_folder(element)  # Якщо це директорія, функція викликає себе рекурсивно, занурюючись глибше.
            elif await element.is_file(): # Якщо елемент — файл, його передають для копіювання.
                await copy_file(element)    # Асинхронно викликаємо функцію копіювання для поточного файлу.
    except (PermissionError, FileNotFoundError) as e: # Обробляє можливі помилки доступу або відсутності директорії, записуючи їх у лог, щоб програма не аварійно завершувалася, а продовжувала роботу з іншими файлами.
        logging.error(f"Cannot access directory {source}: {e}") # Якщо не можемо отримати доступ до директорії, повертаємося, щоб не зупиняти програму


#### 4) Копіюємо кожен файл у конкертну підпадку відповідно до розширення файлу

async def copy_file(file: AsyncPath) -> None:      # Асинхронна функція приймає асинхронний шлях до файлу.
    #TODO Логування обробки помилок через logging
    try:                                             # Використовується блок для обробки будь-яких помилок під час копіювання файлу, наприклад, якщо не вдалося створити директорію або скопіювати файл.
        extension_name = file.suffix[1:] if file.suffix else "no_extension" # Цей рядок отримує розширення файлу. file.suffix повертає рядок на кшталт '.txt', тому [1:] прибирає крапку. Якщо розширення відсутнє, створюється папка no_extension.
        extension_folder = output / extension_name                          # Створює асинхронний шлях до цільової підпапки для файлів з конкретним розширенням.
        
        await extension_folder.mkdir(exist_ok=True, parents=True) # Асинхронно створює цільову підпапку. exist_ok=True запобігає помилці, якщо папка вже існує, а parents=True створює батьківські папки за потреби.
        await copyfile(file, extension_folder / file.name)        # Асинхронно копіює файл з його поточного розташування в щойно створену підпапку.
        logging.info(f"Copied file '{file.name}' to '{extension_folder}'") # Записує повідомлення про успішне копіювання файлу, що допомагає відстежувати прогрес.
    except Exception as e:
        logging.error(f"Failed to copy file '{file.name}': {e}")



#### 0) Налаштовуємо логування виведення інформації в консоль та парсинг аргументів з консолі

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(threadName)s %(message)s") # Налаштовує систему логування, щоб виводити інформацію в консоль.

    parser = argparse.ArgumentParser(
        description="Recursively copy and sort files from source to output by extension."
    ) # Створює парсер аргументів, який допомагає програмі приймати вхідні дані з командного рядка.
    
    parser.add_argument(
        "source",
        type=Path,
        help='Path to the source directory'
    ) #  Додає аргументи source (обов'язковий) і output (необов'язковий, зі значенням за замовчуванням dist).
    parser.add_argument(
        "output",
        nargs="?",
        default=Path("dist"),
        type=Path,
        help="Path to the output directory (default: ./dist)"
    )

    args = parser.parse_args() #  Парсить аргументи, передані користувачем.

    source = AsyncPath(args.source) # Перетворює отримані рядкові шляхи на об'єкти AsyncPath для асинхронної роботи.
    output = AsyncPath(args.output)


### 1) Перевірка наявності та типу вихідної директорії

    async def main():
        if not await source.exists() or not await source.is_dir():     # Це перша асинхронна операція. Вона перевіряє, чи існує об'єкт за шляхом, який зберігається в змінній source. Використання await дозволяє програмі не блокуватися, очікуючи відповіді від файлової системи. if not ... or not ...: Цей умовний вираз комбінує результати обох перевірок. Код у блоці if виконається, якщо: директорія не існує (not await source.exists() є True). або якщо об'єкт існує, але не є директорією (not await source.is_dir() є True).
            logging.error(f"Source directory '{source}' does not exist or is not a directory.") # Друга асинхронна операція, що перевіряє, чи є об'єкт за шляхом source саме директорією. logging.error(...): Якщо умова істинна, записується повідомлення про помилку, що є кращим підходом, ніж просто print(), оскільки це дозволяє налаштувати виведення логів.
            sys.exit(1)                                                                         # Ця команда негайно зупиняє виконання всієї програми з кодом виходу 1. Код 1 зазвичай означає, що програма завершилася з помилкою. Це гарантує, що програма не буде продовжувати роботу з некоректними даними, що може призвести до непередбачуваних результатів.

### 2) Запуск основного процесу сортування (копіювання)        
        logging.info(f"Starting file sorting from '{source}' to '{output}'...") # Якщо попередні перевірки пройшли успішно, цей рядок виводить інформаційне повідомлення, що вказує на початок роботи. Це корисно для моніторингу роботи програми.
        await read_folder(source)                                               # Це основна команда, яка запускає весь процес сортування (копіювання). Вона асинхронно викликає функцію read_folder, передаючи їй шлях до вихідної директорії. Ключове слово await тут є критично важливим, оскільки воно змушує функцію main чекати, доки read_folder (разом з усіма її рекурсивними викликами та копіюванням файлів) повністю не завершить свою роботу.
        logging.info("File sorting completed.")                                 # Після того, як read_folder завершиться, цей рядок виводить фінальне повідомлення про успішне завершення, сигналізуючи, що програма виконала своє завдання.

    asyncio.run(main()) # Запускає асинхронну функцію main. Вона перевіряє існування вихідної папки та запускає процес сортування, а потім виводить повідомлення про завершення.

    # Для перевірки на умову виконання PEP8 рекомендую використати pycodestyle
    # pip install pycodestyle
    # Приклад застосування "pycodestyle --show-source --show-pep8 exercise_10_async.py"


##### Примітка:
# в термінал необхідно ввести наступні команди, аби виконався код вище
# cd "C:\Users\User\Desktop\GOIT\My_repo\Basic-Algorithms-and-Data-Structures\Chapter10"
# py goit-cs-hw-051.py ./pictures ./pictures_copy
# натиснути Enter
# Для перевірки на умову виконання PEP8 рекомендую використати pycodestyle
# ввести в консоль pycodestyle --show-source --show-pep8 goit-cs-hw-051.py
